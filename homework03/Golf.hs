module Golf where

import Data.List

-- Homework 03

----------------------------------

-- Hopscotch
--
-- I decided to place most of the functionality into the separate function
-- called skip.
--
-- This function simply maps skip over a list of Ints from 0 to the last
-- element in xs returning a list of lists which have been generated by skip.
skips :: [a] -> [[a]]
skips xs = map (skip xs) [0..(length xs) - 1]

-- skip contains every element of a list with index i where 'i mod (n + 1)'
-- equals 0 beginning with i = 1.
--
-- Examples:
-- $ skip [0,1,2] 1
-- [1]
--
-- $ skip [0,1,2] 0
-- [0,1,2]
--
-- skip will take one element after it has dropped n elements from the
-- beginning of the list and concatenate that singleton list with the result of
-- a recursive call of skip with 'xs minus the first (n + 1) elements' and 'n'
-- as parameters.
skip :: [a] -> Int -> [a]
skip [] _ = []
skip xs n = (take 1 $ drop n xs) ++ skip (drop (n + 1) xs) n

----------------------------------

-- Local maxima
--
-- localMaxima uses a foldl with a function f, an accumulator [] and (tails xs)
-- as parameters.
--
-- tails returns a list of lists which consist of the last n to
-- 0 elements of its parameter, where n is the length of the parameter.
--
-- The function f in this case uses pattern matching to check if at least three
-- elements remain in its second parameter. It then checks whether the middle
-- element y of the first three elements is bigger than its predecessor and
-- successor in which case the element y is a local maximum and it is to be
-- appended to the accumulator.
localMaxima :: [Integer] -> [Integer]
localMaxima xs = foldl f [] (tails xs)
    where f a (x:y:z:zs) = if y > x && y > z then a ++ [y] else a
          f a _          = a

----------------------------------

-- Histogram
--
-- histogram uses lots of functions from the standard Haskell library.
--
-- To ease the creation of the resulting rows it uses transpose to enable us to
-- create one column of our histogram as one row of characters.
--
-- The function v creates pairs of Ints n and their respective number of times
-- they are contained in the input list. It does so by computing the length of
-- the list of indices of a given integer in the input list.
--
-- For example:
-- $ length $ elemIndices 4 [2,2,4,4]
-- 2
--
-- And conveniently:
--
-- $ length $ elemIndices 4 [2,2]
-- 0
--
-- The function m returns the maximum count of all numbers counted. This number
-- is used to add spaces to columns of less frequent numbers in order to get an
-- even look in our histogram.
--
-- col takes the pairs generated by v and returns the columns of the eventual
-- histogram as strings containing:
--
--  'm - n' spaces (so no spaces in case of our
--  maximum element),
--
--  n stars to represent the number of occurences,
--
--  an equals sign which represents the delimiter between the values and our
--  diagram after our list of strings has been transposed, and finally
--
--  the value belonging to each column
--
-- The resulting list of strings is transposed and turned into a string
-- delimited by newline characters.
histogram :: [Integer] -> String
histogram xs = unlines . transpose . map col $ v
    where col (i, n) = replicate (m - n) ' ' ++ replicate n '*' ++ "=" ++ show i
          m          = maximum $ map snd v
          v          = map (\n -> (n, length $ elemIndices n xs)) [0..9]
